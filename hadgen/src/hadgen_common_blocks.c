#define HADGEN_LIB_INTERNAL

#include <string.h>
#include "hadgen.h"
#include "hadgen_common_blocks.h"
#include <math.h>
#include <stdio.h>

// EVERY THING IS IN SINGLE PRECISION

void *hadgen_get_block(char *block_name) 
{
   if(strcmp(block_name, "RANDOM") == 0) return &random;
   if(strcmp(block_name, "SECHAR") == 0) return &sechar;
   if(strcmp(block_name, "INREAC") == 0) return &inreac;
   if(strcmp(block_name, "SPECAGT") == 0) return &specagt;
   if(strcmp(block_name, "NUMINT") == 0) return &numint;
   if(strcmp(block_name, "HIPROJ") == 0) return &hiproj;
   if(strcmp(block_name, "ANTLAB") == 0) return &antlab;
   if(strcmp(block_name, "ANTIL") == 0) return &antil;
   if(strcmp(block_name, "DEBUG") == 0) return &debug;
   if(strcmp(block_name, "ISLERR") == 0) return &islerr;
   if(strcmp(block_name, "OTHER") == 0) return &other;
   return 0;
}

void hadgen_set_defaults() 
{
   // Initialization of default values 
   // all variables may be changed with other functions
   sechar.LS6 = 6;
   sechar.LS100 = 5000;
   sechar.LS10 = 10;
   sechar.LS11 = 101;
   inreac.COST = 1;
   inreac.SINF = 0;
   inreac.COSF = 1;
   inreac.KSTATE = 2;
   // setup of default flags
   antlab.lanti = 0;
   antil.lantil = 0;
   debug.LSTAR = 0;
   debug.LCASC = 0;
   // RANLUX generator init
   random.IXFIRS = 13457826;  // random seed -- should be changed to time() or smth
   inreac.JPART = 25;
   hiproj.APROJ = 12;
   hiproj.ZPROJ = 6;
   other.LUXCNT = 0;
   inreac.TINT = 1100;
   inreac.NUCLID = 8;
   other.NSTAT = 1; // only one event should be generated by default
}

int hadgen_check_params() 
{
   // checks all the setup before computation
   // refer to original hadgen.f source file
   if (antlab.lanti != 1) antlab.lanti = 0;
   if ((debug.LSTAR != 1) && (debug.LSTAR != 2)) debug.LSTAR = 0;
   if (debug.LCASC != 1) debug.LCASC = 0;

   if (inreac.JPART != 2) antlab.lanti = 0; // Antilab is used only for protons
   if (other.NSTAT > 100) debug.LSTAR = 0; // disable output if more than 100 events
   if ((inreac.TINT > 100) 
    || (inreac.JPART < 1) 
    || (inreac.JPART > 4) 
    || (inreac.NUCLID <= 8)) debug.LCASC = 0;
   if ((inreac.JPART <= 0)
    || (inreac.JPART == 5)
    || ((inreac.JPART >= 12) && (inreac.JPART <= 20))
    || (inreac.JPART > 25)) 
         return 1;	// error in initial data (particle type)
   if ((inreac.TINT < 0) || (inreac.TINT >= 10000001.0)) 
         return 1;	// error in energy value
   if ((inreac.NUCLID < 1) || (inreac.NUCLID > 107)) 
         return 1;	// error: bad nuclid index
   if ((inreac.JPART >= 21) && (inreac.NUCLID == 1)) 
         return 1;	// error

   if (inreac.JPART == 21) { // Deuteron
      hiproj.APROJ=2;
      hiproj.ZPROJ=1;
   }
   if (inreac.JPART == 22) { // Tritium
      hiproj.APROJ=3;
      hiproj.ZPROJ=1;            
   } 
   if (inreac.JPART == 23) { // He3 - nucleus
      hiproj.APROJ=4;
      hiproj.ZPROJ=2;            
   } 
   if (inreac.JPART == 24) { // Alpha particle
      hiproj.APROJ=4;
      hiproj.ZPROJ=2;            
   } 
//   if (inreac.JPART == 25) { // use user provided settings
//      printf("HADGEN: Using projectile with A=%f Z=%f\n", hiproj.APROJ, hiproj.ZPROJ);
//   } 
   if ((inreac.JPART >= 21) && (inreac.JPART<=25)) {
      if ((hiproj.APROJ < 2.0) 
       || (hiproj.APROJ > 260.0)
       || (hiproj.ZPROJ < 1.0)
       || (hiproj.ZPROJ > 100.0)) return 1;	
      // invalid input for APROJ and/or ZPROJ
   }
   return 0;
}

void hadgen_print_setup() {
   printf("HADGEN SETUP: LANTI = %i\n", antlab.lanti);
   printf("              LSTAR = %i\n", debug.LSTAR);
   printf("              LCASC = %i\n", debug.LCASC);
   printf("              JPART = %i\n", inreac.JPART);
   printf("              NSTAT = %i\n", other.NSTAT);
   printf("             NUCLID = %i\n", inreac.NUCLID);
   printf("               TINT = %f\n", inreac.TINT);
   printf("              APROJ = %f\n", hiproj.APROJ);
   printf("              ZPROJ = %f\n", hiproj.ZPROJ);
}

int hadgen_initialize() 
{
   if (hadgen_check_params()) {
      printf("HADGEN: bad params\n");
      return 1;
   }
   // initialize random generator
   random.IX = random.IXFIRS;

   // open files for output from FORTRAN
   openfiles();

   // cleaning
   if (inreac.JPART <= 11) clehad();
 	else cleion();

   _hadgen_setdky();
   
   initam();	// AGT initialization
   _hadgen_initis();    // Izotope mixture of nucleus-target
   inlevr();    // Params of AGT, PRECO, DEEX, CASCAD
   init_lux(&random.IXFIRS, &other.LUXCNT);
   makegrid();
   random.IX = random.IXFIRS;
  
   // next should be MAIN LOOP
   return 0;
}

void hadgen_generate() 
{
   // initialization should be done BEFORE running this function
   // JUST run the main loop as it is in Hadgen
   hadgen_short();
}

void hadgen_terminate() 
{
   closefiles();
}

static int iter_stp_counter = 0;
static int iter_snu_counter = 0;

/*float abs(float x) {
   if (x<0) return -x; else return x;
}*/

float abs_float_(float x) {
   if (x<0) return -x; else return x;
}

int _float_compare(float f1, float f2) {
   if (abs_float_(f1-f2) <= 1e-1) return 1;
   return 0;
}


int _hadgen_get_particle_type(float a5, float a6) {
   if (_float_compare(a6, 3760.)) return PARTICLE_Alpha;
   if (_float_compare(a6, 2820.) 
      && _float_compare(a5, 2.)) return PARTICLE_He3;
   if (_float_compare(a6, 2820.)
      && _float_compare(a5, 1.)) return PARTICLE_Tritium;
   if (_float_compare(a6, 1880.) 
      && _float_compare(a5, 1.)) return PARTICLE_Deuterium;
   if (_float_compare(a6, 12.)
      && _float_compare(a5, 12.)) return PARTICLE_Gamma;
   if (_float_compare(a6, 495.) 
      && _float_compare(a5, 11.)) return PARTICLE_AntiK0;
   if (_float_compare(a6, 495.) 
      && _float_compare(a5, .0)) return PARTICLE_K0;
   if (_float_compare(a6, 495.) 
      && _float_compare(a5, 1.)) return PARTICLE_Kplus;
   if (_float_compare(a6, 495.) 
      && _float_compare(a5, -1.)) return PARTICLE_Kminus;
   if (_float_compare(a6, 940.) 
      && _float_compare(a5, -1.)) return PARTICLE_AntiProton;
   if (_float_compare(a6, 940.) 
      && _float_compare(a5, 6.)) return PARTICLE_AntiNeutron;
   if (_float_compare(a6, 140.) 
      && _float_compare(a5, 0.)) return PARTICLE_PI0;
   if (_float_compare(a6, 140.) 
      && _float_compare(a5, 1.)) return PARTICLE_PIplus;
   if (_float_compare(a6, 140.) 
      && _float_compare(a5, -1.)) return PARTICLE_PIminus;
   if (_float_compare(a6, 940.) 
      && _float_compare(a5, 1.)) return PARTICLE_Proton;
   if (_float_compare(a6, 940.) 
      && _float_compare(a5, 0.)) return PARTICLE_Neutron;
   return PARTICLE_NONE;
   
}

float _hadgen_get_particle_weight(int type) {
   switch(type) {
      case PARTICLE_Neutron:
      case PARTICLE_AntiNeutron:
         return 939.57;
      case PARTICLE_Proton:
      case PARTICLE_AntiProton:
         return 938.27;
      case PARTICLE_PIminus:
      case PARTICLE_PIplus:
         return 139.57;
      case PARTICLE_PI0:
         return 134.98;
      case PARTICLE_Kminus:
      case PARTICLE_Kplus:
         return 493.67;
      case PARTICLE_K0:
      case PARTICLE_AntiK0:
         return 497.65;
      case PARTICLE_Deuterium:
         return 1876.12;
      case PARTICLE_Tritium:
         return 2809.43;
      case PARTICLE_He3:
         return 2808.39;
      case PARTICLE_Alpha:
         return 3727.38;
      case PARTICLE_Gamma:
      case PARTICLE_NONE:
      default: 
         return .0;
   }
}

float _hadgen_get_particle_charge(int type) {
   switch(type) {
      case PARTICLE_Proton:
      case PARTICLE_PIplus:
      case PARTICLE_Kplus:
      case PARTICLE_Deuterium:
      case PARTICLE_Tritium:
         return 1.;
      case PARTICLE_AntiProton:
      case PARTICLE_PIminus:
      case PARTICLE_Kminus:
         return -1.;
      case PARTICLE_He3:
      case PARTICLE_Alpha:
         return 2.;
      case PARTICLE_Neutron:
      case PARTICLE_PI0:
      case PARTICLE_AntiNeutron:
      case PARTICLE_K0:
      case PARTICLE_AntiK0:
      case PARTICLE_Gamma:
      case PARTICLE_NONE:
      default:
         return 0.;
   }
}

float _hadgen_get_particle_lifetime(int type) 
// all output is in [sec]
// MEAN FREE LIFETIME
{
   switch(type) {
      case PARTICLE_Neutron:
      case PARTICLE_AntiNeutron:
         return 885.7;
      case PARTICLE_AntiProton:
      case PARTICLE_Proton:
         return 1e29;         // Stable
      case PARTICLE_PIminus:
      case PARTICLE_PIplus:
         return 2.6e-8;
      case PARTICLE_PI0:
         return 8.4e-17;
      case PARTICLE_Kminus:
      case PARTICLE_Kplus:
         return 1.24e-8;
      case PARTICLE_K0:
      case PARTICLE_AntiK0:
         return 5.116e-8;     // A time for KL (long-living kaon)
      // return 8.953e-11;    // A time for KS (short-living kaon)
      case PARTICLE_Gamma:
         return 1e30;         // Stable
      case PARTICLE_Deuterium:
         return 1e30;         // Stable
      case PARTICLE_Tritium:
         return 3.8852352e+8; 
      case PARTICLE_He3:
         return 1e30;         // Stable?
      case PARTICLE_Alpha:
         return 1e30;         // Stable
      case PARTICLE_NONE:
      default:
         return 0;
   }
}

void hadgen_iter_stp(struct HadgenParticle_t *p) 
{
   if (iter_stp_counter < 5000) {   
      if (sechar.SPT[iter_stp_counter][5] != 0.0) {
         float a5 = sechar.SPT[iter_stp_counter][4];
         p->type = (int)a5;
         float E = (float)(sechar.SPT[iter_stp_counter][3]) * 0.001; // In [GeV] 
         p->Weight = _hadgen_get_particle_weight(p->type) * 0.001; // In [GeV/c^2]
         p->Energy = E;// + p->Weight;
         p->Charge = _hadgen_get_particle_charge(p->type); // In e0
         p->Lifetime = _hadgen_get_particle_lifetime(p->type) * 3e11; // in [mm/c]
         float mc2 = (float)(p->Weight);  // In [GeV]
         float P = sqrt(E * (E + 2.0 * mc2)); // In [GeV/c] 
         float CT = sechar.SPT[iter_stp_counter][0],
               ST = sqrt(1.0 - CT*CT),
               SF = sechar.SPT[iter_stp_counter][1],
               CF = sechar.SPT[iter_stp_counter][2];

         p->Px = ST * CF * P; // All in [GeV/c]
         p->Py = ST * SF * P;
         p->Pz = CT * P;
         iter_stp_counter ++;
      } else {
         // the end of array reached
         p->type = PARTICLE_NONE;
      }
   } else { 
      p->type = PARTICLE_NONE;
   }
}

void hadgen_iter_stp_reset() 
{
   iter_stp_counter = 0;
}

int hadgen_get_max_stp() {
   return 5000;
}

float _float_SQR(float x) {
   return x*x;
}

void hadgen_iter_snu(struct HadgenResidualNuclei_t *p) 
{
   if (iter_snu_counter < 101) { 
      if (sechar.SNU[iter_snu_counter][0] != 0) {
         p->A         = sechar.SNU[iter_snu_counter][0];
         p->Z         = sechar.SNU[iter_snu_counter][1];
         p->ExcEnergy = sechar.SNU[iter_snu_counter][2] * 0.001;
         p->kinter    = sechar.SNU[iter_snu_counter][3];
         p->Px        = sechar.SNU[iter_snu_counter][4] * 0.001;
         p->Py        = sechar.SNU[iter_snu_counter][5] * 0.001;
         p->Pz        = sechar.SNU[iter_snu_counter][6] * 0.001;
         p->Energy    = sqrt(_float_SQR(p->Px) +
                             _float_SQR(p->Py) + 
                             _float_SQR(p->Pz) + 
                             _float_SQR(0.940 * p->A)) - 0.940 * p->A;

         iter_snu_counter++;  
      } else {
         p->A = 0; p->Z = 0;
      }
   } else {
      p->A = 0; p->Z = 0;
   }
}

void hadgen_iter_snu_reset() 
{
   iter_snu_counter = 1;
}

int hadgen_get_max_snu() {
   return 101;
}

void initistest_()
{
    printf("INITIS TEST\n");
    FILE *f = fopen("initis_test.dat", "w");
    int i,j;
    for(i=0; i<500; i++) fprintf(f, "%f %f %f\n", abunuc.AIST[i], abunuc.PERC[i], abunuc.ABUNOR[i]);
    for(i=0; i<110; i++) fprintf(f, "%i %i\n", abunuc.NUCADR[i][0], abunuc.NUCADR[i][1]);
    fprintf(f, "%i\n%i\n", abunuc.IZMAX, abunuc.L110);
    fclose(f);
}
